<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Sensor Visualizer</title>
<style>
  /* Remove all default margin and hide scrollbars */
  body {
    margin: 0;
    overflow: hidden;
    background: #111827; /* Dark background */
  }
  /* The canvas will be injected by three.js and should fill the screen */
  canvas {
    display: block;
  }
</style>
</head>
<body>

<!-- Three.js library from a CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// --- GLOBAL VARIABLES ---
let scene, camera, renderer, box;
let latestData = {
    orientation: { alpha: 0, beta: 0, gamma: 0 }
};

// --- INITIALIZATION ---
function init() {
    // 1. Scene setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111827); // Match body background

    // 2. Camera setup
    const fov = 75;
    const aspect = window.innerWidth / window.innerHeight;
    const near = 0.1;
    const far = 1000;
    camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 5; // Move camera back so we can see the box

    // 3. Renderer setup
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 4. Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // 5. Create the 3D Box
    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const material = new THREE.MeshStandardMaterial({
        color: 0x38bdf8, // A nice blue color
        metalness: 0.5,
        roughness: 0.3
    });
    box = new THREE.Mesh(geometry, material);
    scene.add(box);

    // 6. Handle window resizing
    window.addEventListener('resize', onWindowResize, false);

    // 7. Start fetching data and animating
    fetchSensorData(); // Fetch the first time immediately
    setInterval(fetchSensorData, 50); // Then poll every 50ms
    animate();
}

// --- DATA FETCHING ---
async function fetchSensorData() {
    try {
        const response = await fetch('/sensor');
        const data = await response.json();
        // Update the global data object with the nested orientation values
        if (data && data.orientation) {
            latestData = data;
        }
    } catch (e) {
        console.error("Could not fetch sensor data:", e);
    }
}

// --- ANIMATION LOOP ---
function animate() {
    requestAnimationFrame(animate);

    if (box && latestData.orientation) {
        // Convert degrees from the sensor to radians for three.js
        const alphaRad = THREE.MathUtils.degToRad(latestData.orientation.alpha);
        const betaRad = THREE.MathUtils.degToRad(latestData.orientation.beta);
        const gammaRad = THREE.MathUtils.degToRad(latestData.orientation.gamma);

        // Apply rotations
        // Note: The order of rotations can matter. 'YXZ' is often a good starting point for device orientation.
        const euler = new THREE.Euler(betaRad, alphaRad, -gammaRad, 'YXZ');
        box.setRotationFromEuler(euler);
    }

    renderer.render(scene, camera);
}

// --- EVENT HANDLERS ---
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- START THE APP ---
init();

</script>
</body>
</html>
