<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sensor Visualizer</title>
    <div id="hud">
  <h3>ðŸ“± Phone Sensor Data</h3>
  <table>
    <tbody>
      <tr><th colspan="2">Orientation (deg)</th></tr>
      <tr><td>Alpha (Z)</td><td id="o-alpha">0</td></tr>
      <tr><td>Beta (X)</td><td id="o-beta">0</td></tr>
      <tr><td>Gamma (Y)</td><td id="o-gamma">0</td></tr>

      <tr><th colspan="2">Acceleration (m/sÂ²)</th></tr>
      <tr><td>X</td><td id="a-x">0</td></tr>
      <tr><td>Y</td><td id="a-y">0</td></tr>
      <tr><td>Z</td><td id="a-z">0</td></tr>

      <tr><th colspan="2">Accel + Gravity</th></tr>
      <tr><td>X</td><td id="ag-x">0</td></tr>
      <tr><td>Y</td><td id="ag-y">0</td></tr>
      <tr><td>Z</td><td id="ag-z">0</td></tr>

      <tr><th colspan="2">Rotation Rate (Â°/s)</th></tr>
      <tr><td>Alpha</td><td id="r-alpha">0</td></tr>
      <tr><td>Beta</td><td id="r-beta">0</td></tr>
      <tr><td>Gamma</td><td id="r-gamma">0</td></tr>

      <tr><th colspan="2">Meta</th></tr>
      <tr><td>Interval</td><td id="interval">0</td></tr>
      <tr><td>Datapoints</td><td id="datapoints">0</td></tr>
    </tbody>
  </table>
</div>

    <style>
        /* Remove all default margin and hide scrollbars */
        body {
            margin: 0;
            overflow: hidden;
            background: #111827;
            /* Dark background */
        }

        /* The canvas will be injected by three.js and should fill the screen */
        canvas {
            display: block;
        }
        #hud {
  position: fixed;
  top: 16px;
  left: 16px;
  background: rgba(17, 24, 39, 0.85);
  backdrop-filter: blur(6px);
  color: #e5e7eb;
  padding: 14px;
  border-radius: 14px;
  font-family: monospace;
  font-size: 12px;
  max-width: 260px;
  z-index: 10;
  box-shadow: 0 10px 25px rgba(0,0,0,0.4);
}

#hud h3 {
  margin: 0 0 8px 0;
  font-size: 13px;
  color: #38bdf8;
  text-align: center;
}

#hud table {
  width: 100%;
  border-collapse: collapse;
}

#hud th {
  text-align: left;
  padding-top: 8px;
  color: #93c5fd;
}

#hud td {
  padding: 2px 0;
}

#hud td:last-child {
  text-align: right;
  font-weight: 600;
}

    </style>
</head>

<body>

    <!-- Three.js library from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, box;
        let latestData = {
            orientation: { alpha: 0, beta: 0, gamma: 0 }
        };
function updateHUD(data) {
  const o = data.orientation || {};
  const a = data.acceleration || {};
  const ag = data.accelerationIncludingGravity || {};
  const r = data.rotationRate || {};

  const set = (id, v) =>
    document.getElementById(id).textContent =
      Number.isFinite(v) ? v.toFixed(2) : "0";

  set("o-alpha", o.alpha);
  set("o-beta", o.beta);
  set("o-gamma", o.gamma);

  set("a-x", a.x);
  set("a-y", a.y);
  set("a-z", a.z);

  set("ag-x", ag.x);
  set("ag-y", ag.y);
  set("ag-z", ag.z);

  set("r-alpha", r.alpha);
  set("r-beta", r.beta);
  set("r-gamma", r.gamma);

  document.getElementById("interval").textContent = data.interval || 0;
  document.getElementById("datapoints").textContent = data.datapoints || 0;
}

        // --- INITIALIZATION ---
        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // Match body background

            // 2. Camera setup
            const fov = 75;
            const aspect = window.innerWidth / window.innerHeight;
            const near = 0.1;
            const far = 1000;
            camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 5; // Move camera back so we can see the box

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // 5. Create the 3D Box
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshStandardMaterial({
                color: 0x38bdf8, // A nice blue color
                metalness: 0.5,
                roughness: 0.3
            });
            box = new THREE.Mesh(geometry, material);
            scene.add(box);

            // 6. Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // 7. Start fetching data and animating
            fetchSensorData(); // Fetch the first time immediately
            setInterval(fetchSensorData, 500); // Then poll every 50ms
            animate();
        }

        // --- DATA FETCHING ---
        async function fetchSensorData() {
            try {
                const response = await fetch('/sensor');
                const data = await response.json();
                // Update the global data object with the nested orientation values
                if (data && data.orientation) {
                latestData = data;
                updateHUD(data);
                }

            } catch (e) {
                console.error("Could not fetch sensor data:", e);
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            if (box && latestData.orientation) {
                // Convert degrees from the sensor to radians for three.js
                const alphaRad = THREE.MathUtils.degToRad(latestData.orientation.alpha);
                const betaRad = THREE.MathUtils.degToRad(latestData.orientation.beta);
                const gammaRad = THREE.MathUtils.degToRad(latestData.orientation.gamma);

                // Apply rotations
                // Note: The order of rotations can matter. 'YXZ' is often a good starting point for device orientation.
                const euler = new THREE.Euler(betaRad, alphaRad, -gammaRad, 'YXZ');
                box.setRotationFromEuler(euler);
            }

            renderer.render(scene, camera);
        }

        // --- EVENT HANDLERS ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- START THE APP ---
        init();

    </script>
</body>

</html>